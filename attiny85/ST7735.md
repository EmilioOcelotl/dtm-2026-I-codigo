# Pantalla ST7735

Para echar a andar la [pantalla ST7735](https://uelectronics.com/producto/tft-display-lcd-0-96-spi-hd-65k-colores-st7735/) es importante tener en cuenta que attiny es una placa pequeña de poca potencia. 

Por este motivo no podemos usar archivos de la computadora, pero sí podemos producir imágenes generativas. 

Esto quiere decir que es la misma lógica de programación la que cambia el valor de los pixeles sin una imagen de referencia almacenada en algún lado. 

## Primer paso: Cableado ATtiny85 - Pantalla ST7735

El primer paso consiste en hacer el cableado necesario 

| Pin Digispark  | Conexión Pantalla ST7735  |
|----------------|---------------------------|
| `P0`           | → `CS` (Chip Select)      |
| `P1`           | → `SDA` (Data/MOSI)       |
| `P2`           | → `SCL` (Clock/SCK)       |
| `P3`           | → `DC` (Data/Command)     |
| `P4`           | → `RES` (Reset)           |
| `5V`           | → `VCC` (Alimentación)    |
| `GND`          | → `GND` (Tierra)          |

## Segundo paso: subir el programa con Arduino IDE

Como no vamos a generar geometrías o a tomar imágenes como referencia no necesitamos bibliotecas adicionales. Si el cableado fue realizado de manera adecuada, el siguiente programa debería funcionar: 

```
/*
  ATTINY85 ST7735 - Control Total por Hardware
  Sin dependencias externas
*/

// Definición de pines (actualizada)
#define CS_PIN   0   // PB0 - Chip Select
#define DC_PIN   3   // PB3 - Data/Command  
#define RST_PIN  4   // PB4 - Reset
#define SCK_PIN  2   // PB2 - Clock
// MOSI está en PB1 (hardware)

// Colores en formato RGB565
#define BLACK    0x0000
#define RED      0xF800
#define GREEN    0x07E0
#define BLUE     0x001F
#define WHITE    0xFFFF

// ========== FUNCIONES SPI DE BAJO NIVEL ==========

// Configurar SPI por hardware (USI)
void setupSPI() {
  // Configurar pines como salidas
  DDRB |= (1 << PB1) | (1 << PB2); // PB1 (MOSI), PB2 (SCK) como salidas
  
  // Configurar USI para SPI Master
  USICR = (1 << USIWM0) | (1 << USICS1) | (1 << USICLK);
}

// Enviar un byte por SPI
void SPI_write(uint8_t data) {
  USIDR = data;                    // Cargar dato
  USISR = (1 << USIOIF);           // Limpiar flag de overflow
  
  // Generar 8 pulsos de clock
  while ((USISR & (1 << USIOIF)) == 0) {
    USICR |= (1 << USITC);         // Toggle clock
  }
  
  delayMicroseconds(5);            // Pequeña pausa
}

// ========== FUNCIONES DE CONTROL TFT ==========

// Enviar comando a la pantalla
void sendCommand(uint8_t cmd) {
  digitalWrite(DC_PIN, LOW);       // Modo comando
  digitalWrite(CS_PIN, LOW);       // Seleccionar pantalla
  SPI_write(cmd);                  // Enviar comando
  digitalWrite(CS_PIN, HIGH);      // Deseleccionar
}

// Enviar dato a la pantalla
void sendData(uint8_t data) {
  digitalWrite(DC_PIN, HIGH);      // Modo datos
  digitalWrite(CS_PIN, LOW);       // Seleccionar pantalla
  SPI_write(data);                 // Enviar dato
  digitalWrite(CS_PIN, HIGH);      // Deseleccionar
}

// Enviar dato de 16 bits (color)
void sendData16(uint16_t data) {
  sendData(data >> 8);             // High byte
  sendData(data & 0xFF);           // Low byte
}

// ========== INICIALIZACIÓN TFT ==========

void initTFT() {
  // Configurar pines
  pinMode(CS_PIN, OUTPUT);
  pinMode(DC_PIN, OUTPUT);
  pinMode(RST_PIN, OUTPUT);
  pinMode(SCK_PIN, OUTPUT);
  
  // Desactivar LED del Digispark (PB1)
  pinMode(1, INPUT);
  
  // Configurar SPI
  setupSPI();
  
  // Secuencia de reset
  digitalWrite(CS_PIN, HIGH);
  digitalWrite(RST_PIN, HIGH);
  delay(100);
  digitalWrite(RST_PIN, LOW);
  delay(100);
  digitalWrite(RST_PIN, HIGH);
  delay(120);

  // Secuencia de inicialización ST7735
  sendCommand(0x01);  // Software reset
  delay(120);
  
  sendCommand(0x11);  // Sleep out
  delay(120);
  
  sendCommand(0x3A);  // Color mode
  sendData(0x05);     // 16 bits per pixel
  delay(10);
  
  sendCommand(0x36);  // MADCTL
  sendData(0xC0);     // RGB order
  
  sendCommand(0x29);  // Display on
  delay(100);
}

// ========== FUNCIONES DE DIBUJO ==========

// Establecer área de dibujo
void setAddressWindow(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
  sendCommand(0x2A);  // CASET - Column address set
  sendData(0x00);
  sendData(x0);
  sendData(0x00);
  sendData(x1);
  
  sendCommand(0x2B);  // RASET - Row address set
  sendData(0x00);
  sendData(y0);
  sendData(0x00);
  sendData(y1);
  
  sendCommand(0x2C);  // RAMWR - Memory write
}

// Dibujar un rectángulo sólido
void drawRect(uint8_t x, uint8_t y, uint8_t w, uint8_t h, uint16_t color) {
  setAddressWindow(x, y, x + w - 1, y + h - 1);
  
  digitalWrite(DC_PIN, HIGH);      // Modo datos
  digitalWrite(CS_PIN, LOW);       // Seleccionar pantalla
  
  // Enviar todos los píxeles
  uint32_t totalPixels = (uint32_t)w * h;
  for (uint32_t i = 0; i < totalPixels; i++) {
    SPI_write(color >> 8);         // High byte
    SPI_write(color & 0xFF);       // Low byte
  }
  
  digitalWrite(CS_PIN, HIGH);      // Deseleccionar
}

// Llenar toda la pantalla con un color
void fillScreen(uint16_t color) {
  drawRect(0, 0, 128, 160, color); // Ajustar según tu pantalla
}

// ========== SETUP PRINCIPAL ==========

void setup() {
  // Pequeña pausa al inicio
  delay(1000);
  
  // Inicializar pantalla
  initTFT();
  delay(500);
  
  // Prueba de colores básicos
  fillScreen(RED);
  delay(2000);
  
  fillScreen(GREEN);
  delay(2000);
  
  fillScreen(BLUE);
  delay(2000);
  
  fillScreen(WHITE);
  delay(2000);
}

// ========== LOOP PRINCIPAL ==========

void loop() {
  // Ciclo de colores continuo
  fillScreen(RED);
  delay(1000);
  
  fillScreen(GREEN);
  delay(1000);
  
  fillScreen(BLUE);
  delay(1000);
  
  fillScreen(BLACK);
  delay(1000);
  
  fillScreen(WHITE);
  delay(1000);
}
```

El resultado: La pantalla cambia de color cada cierto tiempo. 